package volume

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/api/types/volume"
	"github.com/docker/docker/errdefs"
	"github.com/portainer/k2d/internal/adapter/store/errors"
	"github.com/portainer/k2d/pkg/maputils"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/kubernetes/pkg/apis/core"
)

// DeleteConfigMap removes a Docker volume corresponding to a Kubernetes ConfigMap.
// The volume name is generated by appending a predefined prefix to the ConfigMap name.
// Returns an error if the Docker volume could not be removed; otherwise, returns nil.
func (store *VolumeStore) DeleteConfigMap(configMapName string) error {
	volumeName := fmt.Sprintf("%s%s", ConfigMapVolumePrefix, configMapName)

	err := store.cli.VolumeRemove(context.TODO(), volumeName, true)
	if err != nil {
		return fmt.Errorf("unable to remove Docker volume: %w", err)
	}

	return nil
}

// GetConfigMapBinds returns the volume names that need to be mounted for a given ConfigMap.
// The volume name is derived from the labels on the ConfigMap.
// Returns a slice of string containing volume names, and an error if any occurs.
func (s *VolumeStore) GetConfigMapBinds(configMap *core.ConfigMap) ([]string, error) {
	return []string{
		configMap.Labels[VolumeNameLabelKey],
	}, nil
}

// GetConfigMap fetches a Kubernetes ConfigMap represented as a Docker volume.
// The function performs a Docker volume inspect operation and converts it into a ConfigMap.
// Returns a pointer to a ConfigMap object, and an error if any occurs.
func (s *VolumeStore) GetConfigMap(configMapName string) (*core.ConfigMap, error) {
	volumeName := fmt.Sprintf("%s%s", ConfigMapVolumePrefix, configMapName)

	volume, err := s.cli.VolumeInspect(context.TODO(), volumeName)
	if err != nil {
		if errdefs.IsNotFound(err) {
			return nil, errors.ErrResourceNotFound
		}
		return nil, fmt.Errorf("unable to inspect Docker volume: %w", err)
	}

	configMap, err := buildConfigMapFromVolume(&volume)
	if err != nil {
		return nil, fmt.Errorf("unable to build config map from volume: %w", err)
	}

	data, err := s.getDataMapFromVolume(volume.Name)
	if err != nil {
		return nil, fmt.Errorf("unable to get data map from volume: %w", err)
	}

	configMap.Data = data

	return &configMap, nil
}

// GetConfigMaps lists all Kubernetes ConfigMaps represented as Docker volumes.
// Filters are applied to list only the volumes that are meant to be ConfigMaps.
// Returns a ConfigMapList object containing all matched ConfigMaps, and an error if any occurs.
func (store *VolumeStore) GetConfigMaps() (core.ConfigMapList, error) {
	filter := filters.NewArgs()
	filter.Add("label", fmt.Sprintf("%s=%s", ResourceTypeLabelKey, ConfigMapResourceType))

	volumes, err := store.cli.VolumeList(context.TODO(), volume.ListOptions{
		Filters: filter,
	})
	if err != nil {
		return core.ConfigMapList{}, fmt.Errorf("unable to list Docker volumes: %w", err)
	}

	configMaps := core.ConfigMapList{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMapList",
			APIVersion: "v1",
		},
		Items: []core.ConfigMap{},
	}

	volumeNames := []string{}
	for _, volume := range volumes.Volumes {
		volumeNames = append(volumeNames, volume.Name)
	}

	volumeData, err := store.getDataMapsFromVolumes(volumeNames)
	if err != nil {
		return core.ConfigMapList{}, fmt.Errorf("unable to get data maps from volumes: %w", err)
	}

	for _, volume := range volumes.Volumes {
		configMap, err := buildConfigMapFromVolume(volume)
		if err != nil {
			store.logger.Warnf("unable to build config map from volume %s: %w", volume.Name, err)
			continue
		}

		configMap.Data = volumeData[volume.Name]

		configMaps.Items = append(configMaps.Items, configMap)
	}

	return configMaps, nil
}

// StoreConfigMap stores a Kubernetes ConfigMap as a Docker volume.
// The volume is labeled to indicate that it represents a ConfigMap.
// Returns an error if the Docker volume could not be created; otherwise, returns nil.
func (store *VolumeStore) StoreConfigMap(configMap *corev1.ConfigMap) error {
	volumeName := fmt.Sprintf("%s%s", ConfigMapVolumePrefix, configMap.Name)

	labels := map[string]string{
		ResourceTypeLabelKey: ConfigMapResourceType,
	}
	maputils.MergeMapsInPlace(labels, configMap.Labels)

	volume, err := store.cli.VolumeCreate(context.TODO(), volume.CreateOptions{
		Name:   volumeName,
		Labels: labels,
	})
	if err != nil {
		return fmt.Errorf("unable to create Docker volume: %w", err)
	}

	err = store.copyDataMapToVolume(volume.Name, configMap.Data)
	if err != nil {
		return fmt.Errorf("unable to copy data map to volume: %w", err)
	}

	return nil
}

// buildConfigMapFromVolume constructs a Kubernetes ConfigMap object from a Docker volume.
// Returns a ConfigMap object, and an error if any occurs (e.g., if the volume's creation timestamp is not parseable).
func buildConfigMapFromVolume(volume *volume.Volume) (core.ConfigMap, error) {
	configMap := core.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMap",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:        strings.TrimPrefix(volume.Name, ConfigMapVolumePrefix),
			Annotations: map[string]string{},
			Namespace:   "default",
			Labels:      volume.Labels,
		},
		Data: map[string]string{},
	}

	configMap.Labels[VolumeNameLabelKey] = volume.Name

	parsedTime, err := time.Parse(time.RFC3339, volume.CreatedAt)
	if err != nil {
		return core.ConfigMap{}, err
	}

	configMap.ObjectMeta.CreationTimestamp = metav1.NewTime(parsedTime)

	return configMap, nil
}
