package volume

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/api/types/volume"
	"github.com/docker/docker/errdefs"
	"github.com/portainer/k2d/internal/adapter/store/errors"
	"github.com/portainer/k2d/pkg/maputils"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/kubernetes/pkg/apis/core"
)

// TODO: update function comments with namespace support

// DeleteSecret removes a Docker volume corresponding to a Kubernetes Secret.
// The volume name is generated by appending a predefined prefix to the Secret name.
// Returns an error if the Docker volume could not be removed; otherwise, returns nil.
func (s *VolumeStore) DeleteSecret(secretName, namespace string) error {
	volumeName := buildSecretVolumeName(secretName, namespace)

	err := s.cli.VolumeRemove(context.TODO(), volumeName, true)
	if err != nil {
		return fmt.Errorf("unable to remove Docker volume: %w", err)
	}

	return nil
}

// GetSecretBinds returns the volume names that need to be mounted for a given Secret.
// The volume name is derived from the labels on the Secret.
// It returns a single bind with an empty key (representing the file name in the container) and the volume name as value.
func (s *VolumeStore) GetSecretBinds(secret *core.Secret) (map[string]string, error) {
	return map[string]string{
		"": secret.Labels[VolumeNameLabelKey],
	}, nil
}

// GetSecret fetches a Kubernetes Secret represented as a Docker volume.
// The function performs a Docker volume inspect operation and converts it into a Secret.
// Returns a pointer to a Secret object, and an error if any occurs.
func (s *VolumeStore) GetSecret(secretName, namespace string) (*core.Secret, error) {
	volumeName := buildSecretVolumeName(secretName, namespace)

	volume, err := s.cli.VolumeInspect(context.TODO(), volumeName)
	if err != nil {
		if errdefs.IsNotFound(err) {
			return nil, errors.ErrResourceNotFound
		}
		return nil, fmt.Errorf("unable to inspect Docker volume: %w", err)
	}

	secret, err := buildSecretFromVolume(&volume)
	if err != nil {
		return nil, fmt.Errorf("unable to build secret from volume: %w", err)
	}

	data, err := s.getDataMapFromVolume(volume.Name)
	if err != nil {
		return nil, fmt.Errorf("unable to get data map from volume: %w", err)
	}

	secret.Data = maputils.ConvertMapStringToStringSliceByte(data)

	return &secret, nil
}

// GetSecrets lists all Kubernetes Secrets represented as Docker volumes.
// Filters are applied to list only the volumes that are meant to be Secrets.
// Returns a SecretList object containing all matched Secrets, and an error if any occurs.
func (s *VolumeStore) GetSecrets(namespace string, selector labels.Selector) (core.SecretList, error) {
	filter := filters.NewArgs()
	filter.Add("label", fmt.Sprintf("%s=%s", ResourceTypeLabelKey, SecretResourceType))
	filter.Add("label", fmt.Sprintf("%s=%s", NamespaceNameLabelKey, namespace))

	volumes, err := s.cli.VolumeList(context.TODO(), volume.ListOptions{
		Filters: filter,
	})
	if err != nil {
		return core.SecretList{}, fmt.Errorf("unable to list Docker volumes: %w", err)
	}

	filteredVolumes := []volume.Volume{}
	for _, volume := range volumes.Volumes {
		if selector.Matches(labels.Set(volume.Labels)) {
			filteredVolumes = append(filteredVolumes, *volume)
		}
	}

	secrets := core.SecretList{
		TypeMeta: metav1.TypeMeta{
			Kind:       "SecretList",
			APIVersion: "v1",
		},
		Items: []core.Secret{},
	}

	volumeNames := []string{}
	for _, volume := range filteredVolumes {
		volumeNames = append(volumeNames, volume.Name)
	}

	volumeData, err := s.getDataMapsFromVolumes(volumeNames)
	if err != nil {
		return core.SecretList{}, fmt.Errorf("unable to get data maps from volumes: %w", err)
	}

	for _, volume := range filteredVolumes {
		secret, err := buildSecretFromVolume(&volume)
		if err != nil {
			s.logger.Warnf("unable to build secret from volume %s: %w", volume.Name, err)
			continue
		}

		secret.Data = maputils.ConvertMapStringToStringSliceByte(volumeData[volume.Name])

		secrets.Items = append(secrets.Items, secret)
	}

	return secrets, nil
}

// StoreSecret stores a Kubernetes Secret as a Docker volume.
// The volume is labeled to indicate that it represents a Secret.
// Returns an error if the Docker volume could not be created; otherwise, returns nil.
func (s *VolumeStore) StoreSecret(secret *corev1.Secret) error {
	volumeName := buildSecretVolumeName(secret.Name, secret.Namespace)

	labels := map[string]string{
		ResourceTypeLabelKey:  SecretResourceType,
		NamespaceNameLabelKey: secret.Namespace,
	}
	maputils.MergeMapsInPlace(labels, secret.Labels)

	volume, err := s.cli.VolumeCreate(context.TODO(), volume.CreateOptions{
		Name:   volumeName,
		Labels: labels,
	})
	if err != nil {
		return fmt.Errorf("unable to create Docker volume: %w", err)
	}

	data := map[string]string{}

	for key, value := range secret.Data {
		data[key] = string(value)
	}

	for key, value := range secret.StringData {
		data[key] = value
	}

	err = s.copyDataMapToVolume(volume.Name, data)
	if err != nil {
		return fmt.Errorf("unable to copy data map to volume: %w", err)
	}

	return nil
}

// Each secret is stored as a Docker volume using the following naming convention:
// secret-[namespace]-[secret-name]
func buildSecretVolumeName(configMapName, namespace string) string {
	return fmt.Sprintf("%s%s-%s", SecretVolumePrefix, namespace, configMapName)
}

func getSecretNameFromVolumeName(volumeName, namespace string) string {
	return strings.TrimPrefix(volumeName, fmt.Sprintf("%s%s-", SecretVolumePrefix, namespace))
}

// buildSecretFromVolume constructs a Kubernetes Secret object from a Docker volume.
// Returns a Secret object, and an error if any occurs (e.g., if the volume's creation timestamp is not parseable).
func buildSecretFromVolume(volume *volume.Volume) (core.Secret, error) {
	namespace := volume.Labels[NamespaceNameLabelKey]

	secret := core.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:        getSecretNameFromVolumeName(volume.Name, namespace),
			Annotations: map[string]string{},
			Namespace:   namespace,
			Labels:      volume.Labels,
		},
		Data: map[string][]byte{},
		Type: core.SecretTypeOpaque,
	}

	secret.Labels[VolumeNameLabelKey] = volume.Name

	parsedTime, err := time.Parse(time.RFC3339, volume.CreatedAt)
	if err != nil {
		return core.Secret{}, err
	}

	secret.ObjectMeta.CreationTimestamp = metav1.NewTime(parsedTime)

	return secret, nil
}
